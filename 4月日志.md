# 4.1
amcl自适应蒙特卡洛算法，使用地图信息和当前获取的激光雷达数据进行机器人定位
AMCL是Adaptive Monte Carlo Localization（也即是自适应蒙特卡洛定位）的简称，是基于多种蒙特卡洛融合算法在ROS/ROS2系统中的一种实现。
蒙特卡洛定位（MCL）基于粒子滤波算法，其一大优点是不受场景的限制，算法简捷快速，同时也可以兼顾算法的精度问题。

粒子滤波使用粒子密度（也就是单位区间内的粒子数）表征事件的发生概率。根据选定的评估方程来推算事件的置信程度，并根据该结果重新调整粒子的分布情况。经过若干次迭代之后，粒子就高度分布在可能性高的区域了。

基于这种推论，MCL将复杂的数学运算，转换成了计算机更易理解的迭代求解，在机器人定位问题上得到了很好的泛化。

如上图所示，在AMCL包中，选型、配置了运动模型、传感器模型、蒙特卡洛航位推算算法、采样算法等等功能模块。传感器模型将传感器数据结构化，运动模型将机器人的运动进行分解和代数化。传感器模型和运动模型相辅相成，紧密合作，为蒙特卡洛滤波做好数据支撑。采样/重采样算法为定位的迭代运算和误差消除提供保障。
ros中在nav模块中已经集成了AMCL相关的实现。

nav模块在前期的工作中已经配置好了。

编写launch文件将amcl集成在仿真环境中，暂时取消gmapping节点。

运行仿真环境在rviz中订阅定位信息。

运行键盘控制节点，控制机器人移动，可以发现，在机器人处于障碍物信息较为丰富的区域（拐角，棱角处），会获得相对较好的位姿估计。

# 4.2

movebase功能包

理解movebase运行框架和轨迹规划的流程。

move_base节点主要基于地图传感器等提供的环境信息、根据机器人当前的位姿和指定的规划器提供的规划算法，规划出一条有效的全局路径和运动速度命令，从而实现定点避障导航行驶的功能。

路径规划主要有下面的两大规划器组成：

全局路径规划（global_planner）：根据给定的目标位置和全局地图进行总体的路劲规划。在导航中，使用迪特斯克或者A*算法进行全局路径的规划，计算出最佳路径

本地实施规划（local_planner）：实际情况下，由于可能出现障碍物，无法完美按照全局路径规划。本地实施规划由local_planner模块实现，使用Dynamic Window Approaches算法搜索躲避障碍物行进的多条路径，综合评价标准（是否撞击障碍物，所需的时间）选取最优路径，并且计算行驶周期内的线速度和角速度，避免与动态的障碍物发生碰撞。

# 4.3

配置movebase功能包运行环境，安装依赖。进行源码编译。

在launch文件中加载movebase节点。

movebase需要订阅目标点的消息。目标点使用rviz的快捷工具发送。

# 4.4
gmapping，amcl，movebase集成，实现给定目标点的自主建图

在launch文件中集成三个节点，开启仿真环境。

通过在位置区域，给定目标点，机器人边进行路径规划，边进行自主建图

使用map-server保存地图生成本地地图文件和地图描述yaml文件。

# 4.5

复习《视觉slam14讲》关于视觉里程计和重投影误差的计算相关内容，形成笔记。
重投影误差
其实第一次投影指的就是相机在拍照的时候，三维空间点投影到图像上。
然后我们利用这些图像对一些特征点进行三角定位（triangulation），利用几何信息（对极几何） 构建三角形来确定三维空间点的位置
最后利用我们计算得到的三维点的坐标（注意不是真实的）和我们计算得到的相机位姿（当然也不是真实的）进行第二次投影，也就是重投影。
重投影误差：指的真实三维空间点在图像平面上的投影（也就是图像上的像素点）和重投影（其实是用我们的计算值得到的虚拟的像素点）的差值，
因为种种原因计算得到的值和实际情况不会完全相符，也就是这个差值不可能恰好为0，此时也就需要将这些差值的和最小化获取最优的相机位姿参数及三维空间点的坐标。

# 4.6
复习非线性优化方法
最速梯度下降法和高斯牛顿法

<img src="0406-1.PNG">

<img src="0406-2.PNG">


# 4.7

复习BA优化
Bundle Adjustment
译为光束法平差，或者束调整、捆集调整。       
所谓bundle，来源于bundle of light，其本意就是指的光束，这些光束指的是三维空间中的点投影到像平面上的光束，而重投影误差正是利用这些光束来构建的，因此称为光束法，强调光束也正是描述其优化模型是如何建立的。
测量平差：由于测量仪器的精度不完善和人为因素及外界条件的影响，测量误差总是不可避免的。为了提高成果的质量，处理好这些测量中存在的误差问题，观测值的个数往往要多于确定未知量所必须观测的个数，也就是要进行多余观测。有了多余观测，势必在观测结果之间产生矛盾，测量平差的目的就在于消除这些矛盾而求得观测量的最可靠结果并评定测量成果的精度。测量平差采用的原理就是“最小二乘法”。（通过多次测量平衡误差？）

重投影误差
其实第一次投影指的就是相机在拍照的时候，三维空间点投影到图像上。
然后我们利用这些图像对一些特征点进行三角定位（triangulation），利用几何信息（对极几何） 构建三角形来确定三维空间点的位置
最后利用我们计算得到的三维点的坐标（注意不是真实的）和我们计算得到的相机位姿（当然也不是真实的）进行第二次投影，也就是重投影。
重投影误差：指的真实三维空间点在图像平面上的投影（也就是图像上的像素点）和重投影（其实是用我们的计算值得到的虚拟的像素点）的差值，
因为种种原因计算得到的值和实际情况不会完全相符，也就是这个差值不可能恰好为0，此时也就需要将这些差值的和最小化获取最优的相机位姿参数及三维空间点的坐标。
1.重投影
相机在拍照时会把空间点投影到图像上，这是第一次投影。我们利用这些图像进行特征匹配，然后对匹配的特征点进行三角化，得到三维空间点位置（如上图中的）。最后我们利用计算得到的三维点的坐标（估计值，具有误差）和我们计算得到的相机矩阵（具有误差）进行第二次投影，也就是重投影。

BA的目的就是优化相机的位姿（变换矩阵T），使得整体误差（不是误差的代数和，是平方和，构建了最小二乘问题）最小。

# 4.10

准备组会内容，与师兄讨论算法具体实现。海塞矩阵求解以及高斯牛顿法的位姿估计实现。

感知质量的评定规则，感知质量数值的尺度如何与A*算法中其他代价项的尺度统一。

对于A*算法中出现的代价和感知质量如何结合做讨论。

制定后续的试验方案


